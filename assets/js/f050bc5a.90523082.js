"use strict";(self.webpackChunkrahat_documentation=self.webpackChunkrahat_documentation||[]).push([[9737],{27913:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Data-and-Integration/Offramp-Service-Integration","title":"Offramp Service Integration","description":"This document provides comprehensive guidance on integrating offramp services with the Rahat platform for token-to-fiat conversion and local payment processing.","source":"@site/dev-docs/Data-and-Integration/03.Offramp-Service-Integration.md","sourceDirName":"Data-and-Integration","slug":"/Data-and-Integration/Offramp-Service-Integration","permalink":"/dev-docs/Data-and-Integration/Offramp-Service-Integration","draft":false,"unlisted":false,"editUrl":"https://github.com/rahataid/rahat-documentation/blob/dev/dev-docs/Data-and-Integration/03.Offramp-Service-Integration.md","tags":[],"version":"current","lastUpdatedAt":1758175872000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Offramp Service Integration"},"sidebar":"myAutogeneratedSidebar","previous":{"title":"Using TheGraph for Indexing","permalink":"/dev-docs/Data-and-Integration/Using-Subgraph-for-Indexing"},"next":{"title":"External Forecast Data Sources","permalink":"/dev-docs/Data-and-Integration/External-Oracle-Weather-API-Setup"}}');var a=t(74848),i=t(28453);const s={sidebar_position:3,title:"Offramp Service Integration"},o="Offramp Service Integration",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"1. Offramp Service",id:"1-offramp-service",level:4},{value:"2. Payment Providers",id:"2-payment-providers",level:4},{value:"3. Payout Management",id:"3-payout-management",level:4},{value:"Integration Setup",id:"integration-setup",level:2},{value:"1. Environment Configuration",id:"1-environment-configuration",level:3},{value:"2. Database Settings",id:"2-database-settings",level:3},{value:"Service Implementation",id:"service-implementation",level:2},{value:"1. Offramp Service Class",id:"1-offramp-service-class",level:3},{value:"2. Data Interfaces",id:"2-data-interfaces",level:3},{value:"Integration Workflow",id:"integration-workflow",level:2},{value:"1. Payout Initiation",id:"1-payout-initiation",level:3},{value:"2. Token Transfer Process",id:"2-token-transfer-process",level:3},{value:"3. Offramp Processing",id:"3-offramp-processing",level:3},{value:"Payment Provider Integration",id:"payment-provider-integration",level:2},{value:"1. Bank Transfer Integration",id:"1-bank-transfer-integration",level:3},{value:"2. VPA (Virtual Payment Address) Integration",id:"2-vpa-virtual-payment-address-integration",level:3},{value:"3. Mobile Money Integration",id:"3-mobile-money-integration",level:3},{value:"Error Handling and Retry Logic",id:"error-handling-and-retry-logic",level:2},{value:"1. Error Types",id:"1-error-types",level:3},{value:"2. Retry Configuration",id:"2-retry-configuration",level:3},{value:"3. Error Handling Implementation",id:"3-error-handling-implementation",level:3},{value:"Monitoring and Analytics",id:"monitoring-and-analytics",level:2},{value:"1. Transaction Tracking",id:"1-transaction-tracking",level:3},{value:"2. Status Tracking",id:"2-status-tracking",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. Authentication",id:"1-authentication",level:3},{value:"2. Data Validation",id:"2-data-validation",level:3},{value:"3. Rate Limiting",id:"3-rate-limiting",level:3},{value:"Testing",id:"testing",level:2},{value:"1. Unit Tests",id:"1-unit-tests",level:3},{value:"2. Integration Tests",id:"2-integration-tests",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Configuration Management",id:"1-configuration-management",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Monitoring",id:"3-monitoring",level:3},{value:"4. Security",id:"4-security",level:3},{value:"5. Performance",id:"5-performance",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Common Issues",id:"common-issues",level:3},{value:"Debug Tools",id:"debug-tools",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"offramp-service-integration",children:"Offramp Service Integration"})}),"\n",(0,a.jsx)(e.p,{children:"This document provides comprehensive guidance on integrating offramp services with the Rahat platform for token-to-fiat conversion and local payment processing."}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Offramp services enable the conversion of blockchain tokens to local currency and facilitate distribution to beneficiaries through various payment methods. The integration supports multiple payment providers and ensures seamless cash distribution workflows."}),"\n",(0,a.jsx)(e.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,a.jsx)(e.h4,{id:"1-offramp-service",children:"1. Offramp Service"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),": Token-to-fiat conversion and local payment processing"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Integration"}),": REST API with authentication"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Features"}),": Instant conversion, bank transfers, VPA payments, mobile money"]}),"\n"]}),"\n",(0,a.jsx)(e.h4,{id:"2-payment-providers",children:"2. Payment Providers"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),": Local financial service provider integration"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Features"}),": Multiple provider support, transaction tracking"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Methods"}),": Bank transfers, mobile money, VPA (Virtual Payment Address)"]}),"\n"]}),"\n",(0,a.jsx)(e.h4,{id:"3-payout-management",children:"3. Payout Management"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Purpose"}),": Orchestrate the entire payout process"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Features"}),": Batch processing, status tracking, error handling"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"integration-setup",children:"Integration Setup"}),"\n",(0,a.jsx)(e.h3,{id:"1-environment-configuration",children:"1. Environment Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Configure the following environment variables for offramp service integration:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-bash",children:"# Offramp Service Settings\nOFFRAMP_URL=https://api.offramp-service.com\nOFFRAMP_APP_ID=your_app_id\nOFFRAMP_ACCESS_TOKEN=your_access_token\nOFFRAMP_DEFAULT_PAYMENT_PROVIDER=provider_id\n\n# Transaction Limits\nOFFRAMP_MIN_AMOUNT=10\nOFFRAMP_MAX_AMOUNT=10000\nOFFRAMP_DAILY_LIMIT=50000\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-database-settings",children:"2. Database Settings"}),"\n",(0,a.jsx)(e.p,{children:"Store offramp configuration in the settings table:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",children:'INSERT INTO settings (name, value, description) VALUES \n(\'OFFRAMP_SETTINGS\', \'{\n  "URL": "https://api.offramp-service.com",\n  "APP_ID": "your_app_id",\n  "ACCESS_TOKEN": "your_access_token",\n  "DEFAULT_PAYMENT_PROVIDER": "provider_id",\n  "TRANSACTION_LIMITS": {\n    "MIN_AMOUNT": 10,\n    "MAX_AMOUNT": 10000,\n    "DAILY_LIMIT": 50000\n  }\n}\', \'Offramp service configuration\');\n'})}),"\n",(0,a.jsx)(e.h2,{id:"service-implementation",children:"Service Implementation"}),"\n",(0,a.jsx)(e.h3,{id:"1-offramp-service-class",children:"1. Offramp Service Class"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"import { Injectable, HttpService } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class OfframpService {\n  constructor(\n    private readonly httpService: HttpService,\n    private readonly configService: ConfigService,\n    private readonly coreClient: ClientProxy\n  ) {}\n\n  /**\n   * Fetch offramp service settings from database\n   */\n  async fetchOfframpSettings(): Promise<{\n    url: string;\n    appId: string;\n    accessToken: string;\n    defaultPaymentProvider: string;\n    transactionLimits: {\n      minAmount: number;\n      maxAmount: number;\n      dailyLimit: number;\n    };\n  }> {\n    const settings = await this.coreClient.send({\n      cmd: 'SETTINGS.GET',\n      data: { name: 'OFFRAMP_SETTINGS' }\n    });\n\n    return {\n      url: settings.value.URL,\n      appId: settings.value.APP_ID,\n      accessToken: settings.value.ACCESS_TOKEN,\n      defaultPaymentProvider: settings.value.DEFAULT_PAYMENT_PROVIDER,\n      transactionLimits: settings.value.TRANSACTION_LIMITS\n    };\n  }\n\n  /**\n   * Get offramp wallet address for token transfers\n   */\n  async getOfframpWalletAddress(): Promise<string> {\n    const offrampSettings = await this.fetchOfframpSettings();\n    \n    const response = await this.httpService.axiosRef.get(\n      `${offrampSettings.url}/app/${offrampSettings.appId}`,\n      {\n        headers: { \n          'APP_ID': offrampSettings.appId,\n          'Authorization': `Bearer ${offrampSettings.accessToken}`\n        }\n      }\n    );\n\n    return response.data.data.wallet;\n  }\n\n  /**\n   * Get available payment providers\n   */\n  async getPaymentProviders(): Promise<IPaymentProvider[]> {\n    const offrampSettings = await this.fetchOfframpSettings();\n    \n    const response = await this.httpService.axiosRef.get(\n      `${offrampSettings.url}/payment-providers`,\n      {\n        headers: { \n          'APP_ID': offrampSettings.appId,\n          'Authorization': `Bearer ${offrampSettings.accessToken}`\n        }\n      }\n    );\n\n    return response.data.data;\n  }\n\n  /**\n   * Process instant offramp conversion\n   */\n  async instantOfframp(offrampPayload: OfframpRequest): Promise<OfframpResponse> {\n    const offrampSettings = await this.fetchOfframpSettings();\n    \n    const response = await this.httpService.axiosRef.post(\n      `${offrampSettings.url}/offramp-request/instant`,\n      offrampPayload,\n      {\n        headers: { \n          'APP_ID': offrampSettings.appId,\n          'Authorization': `Bearer ${offrampSettings.accessToken}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n\n    return response.data.data;\n  }\n\n  /**\n   * Add bulk transactions to offramp queue\n   */\n  async addBulkToOfframpQueue(transactions: FSPOfframpDetails[]): Promise<void> {\n    const offrampSettings = await this.fetchOfframpSettings();\n    \n    await this.httpService.axiosRef.post(\n      `${offrampSettings.url}/offramp-request/bulk`,\n      { transactions },\n      {\n        headers: { \n          'APP_ID': offrampSettings.appId,\n          'Authorization': `Bearer ${offrampSettings.accessToken}`,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-data-interfaces",children:"2. Data Interfaces"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Payment Provider Interface\ninterface IPaymentProvider {\n  id: string;\n  name: string;\n  type: 'BANK' | 'MOBILE_MONEY' | 'VPA' | 'CASH';\n  country: string;\n  currency: string;\n  supportedMethods: string[];\n  processingTime: string;\n  fees: {\n    percentage: number;\n    fixed: number;\n  };\n  limits: {\n    minAmount: number;\n    maxAmount: number;\n    dailyLimit: number;\n  };\n}\n\n// Offramp Request Interface\ninterface OfframpRequest {\n  tokenAmount: number;\n  paymentProviderId: string;\n  transactionHash: string;\n  senderAddress: string;\n  xref: string;\n  paymentDetails: {\n    creditorAgent?: string;\n    creditorAccount?: string;\n    creditorName?: string;\n    vpa?: string;\n  };\n}\n\n// Offramp Response Interface\ninterface OfframpResponse {\n  id: string;\n  status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED';\n  transactionId: string;\n  amount: number;\n  currency: string;\n  paymentProvider: string;\n  processingTime: number;\n  fees: number;\n  errorMessage?: string;\n}\n\n// FSP Offramp Details Interface\ninterface FSPOfframpDetails {\n  amount: number;\n  beneficiaryWalletAddress: string;\n  beneficiaryBankDetails: {\n    bankName: string;\n    accountNumber: string;\n    accountName: string;\n    ifscCode?: string;\n  };\n  payoutUUID: string;\n  payoutProcessorId: string;\n  beneficiaryPhoneNumber: string;\n  offrampWalletAddress: string;\n  offrampType: string;\n  transactionHash?: string;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-workflow",children:"Integration Workflow"}),"\n",(0,a.jsx)(e.h3,{id:"1-payout-initiation",children:"1. Payout Initiation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"@Injectable()\nexport class PayoutsService {\n  constructor(\n    private readonly offrampService: OfframpService,\n    private readonly stellarService: StellarService,\n    private readonly prisma: PrismaService\n  ) {}\n\n  async triggerPayout(uuid: string): Promise<any> {\n    const payoutDetails = await this.findOne(uuid);\n    \n    if (payoutDetails.isPayoutTriggered) {\n      throw new RpcException(\n        `Payout with UUID '${uuid}' has already been triggered`\n      );\n    }\n\n    const BeneficiaryPayoutDetails = await this.fetchBeneficiaryPayoutDetails(uuid);\n    const offrampWalletAddress = await this.offrampService.getOfframpWalletAddress();\n\n    const stellerOfframpQueuePayload: FSPPayoutDetails[] = \n      BeneficiaryPayoutDetails.map((beneficiary) => ({\n        amount: beneficiary.amount,\n        beneficiaryWalletAddress: beneficiary.walletAddress,\n        beneficiaryBankDetails: beneficiary.bankDetails,\n        payoutUUID: uuid,\n        payoutProcessorId: payoutDetails.payoutProcessorId,\n        beneficiaryPhoneNumber: beneficiary.phoneNumber,\n        offrampWalletAddress,\n        offrampType: payoutExtras.paymentProviderType,\n      }));\n\n    await this.stellarService.addBulkToTokenTransferQueue(\n      stellerOfframpQueuePayload\n    );\n\n    return 'Payout Initiated Successfully';\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-token-transfer-process",children:"2. Token Transfer Process"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"@Processor(BQUEUE.STELLAR)\nexport class StellarProcessor {\n  @Process(JOBS.STELLAR.TRANSFER_TO_OFFRAMP)\n  async processTransferToOfframp(job: Job) {\n    const payload: FSPPayoutDetails = job.data;\n    \n    try {\n      // Transfer tokens from beneficiary to offramp wallet\n      const transactionResult = await this.stellarService.transferTokens({\n        fromAddress: payload.beneficiaryWalletAddress,\n        toAddress: payload.offrampWalletAddress,\n        amount: payload.amount,\n        assetCode: 'RAHAT',\n        assetIssuer: process.env.STELLAR_ASSET_ISSUER\n      });\n\n      // Update payload with transaction hash\n      payload.transactionHash = transactionResult.hash;\n\n      // Add to offramp queue for cash conversion\n      await this.offrampService.addBulkToOfframpQueue([payload]);\n\n      return transactionResult;\n    } catch (error) {\n      this.logger.error(`Token transfer failed: ${error.message}`);\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-offramp-processing",children:"3. Offramp Processing"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"@Processor(BQUEUE.OFFRAMP)\nexport class OfframpProcessor {\n  @Process(JOBS.OFFRAMP.PROCESS_CONVERSION)\n  async processOfframpConversion(job: Job) {\n    const payload: FSPOfframpDetails = job.data;\n    \n    try {\n      const offrampRequest = await this.generateOfframpPayload(\n        payload.offrampType,\n        payload\n      );\n\n      const offrampResponse = await this.offrampService.instantOfframp(offrampRequest);\n\n      // Update beneficiary redeem status\n      await this.prisma.beneficiaryRedeem.update({\n        where: { \n          payoutUUID_beneficiaryId: {\n            payoutUUID: payload.payoutUUID,\n            beneficiaryId: payload.beneficiaryId\n          }\n        },\n        data: {\n          status: offrampResponse.status,\n          offrampResponse: offrampResponse,\n          transactionHash: payload.transactionHash\n        }\n      });\n\n      return offrampResponse;\n    } catch (error) {\n      this.logger.error(`Offramp conversion failed: ${error.message}`);\n      \n      // Update status to failed\n      await this.prisma.beneficiaryRedeem.update({\n        where: { \n          payoutUUID_beneficiaryId: {\n            payoutUUID: payload.payoutUUID,\n            beneficiaryId: payload.beneficiaryId\n          }\n        },\n        data: {\n          status: 'FAILED',\n          errorMessage: error.message,\n          numberOfAttempts: { increment: 1 }\n        }\n      });\n\n      throw error;\n    }\n  }\n\n  private async generateOfframpPayload(\n    offrampType: string,\n    fspOfframpDetails: FSPOfframpDetails\n  ): Promise<OfframpRequest> {\n    let offrampRequest: OfframpRequest = {\n      tokenAmount: fspOfframpDetails.amount,\n      paymentProviderId: fspOfframpDetails.payoutProcessorId,\n      transactionHash: fspOfframpDetails.transactionHash,\n      senderAddress: fspOfframpDetails.beneficiaryWalletAddress,\n      xref: fspOfframpDetails.payoutUUID,\n      paymentDetails: {}\n    };\n\n    if (offrampType.toLowerCase() === 'bank') {\n      offrampRequest.paymentDetails = {\n        creditorAgent: getBankId(fspOfframpDetails.beneficiaryBankDetails.bankName),\n        creditorAccount: fspOfframpDetails.beneficiaryBankDetails.accountNumber,\n        creditorName: fspOfframpDetails.beneficiaryBankDetails.accountName,\n      };\n    } else if (offrampType.toLowerCase() === 'vpa') {\n      offrampRequest.paymentDetails = {\n        vpa: fspOfframpDetails.beneficiaryPhoneNumber,\n      };\n    }\n\n    return offrampRequest;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"payment-provider-integration",children:"Payment Provider Integration"}),"\n",(0,a.jsx)(e.h3,{id:"1-bank-transfer-integration",children:"1. Bank Transfer Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Bank transfer configuration\ninterface BankTransferConfig {\n  bankName: string;\n  accountNumber: string;\n  accountName: string;\n  ifscCode?: string;\n  routingNumber?: string;\n}\n\n// Get bank ID mapping\nfunction getBankId(bankName: string): string {\n  const bankMapping = {\n    'SBI': 'SBIN0000001',\n    'HDFC': 'HDFC0000001',\n    'ICICI': 'ICIC0000001',\n    // Add more bank mappings\n  };\n  \n  return bankMapping[bankName] || bankName;\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-vpa-virtual-payment-address-integration",children:"2. VPA (Virtual Payment Address) Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// VPA payment configuration\ninterface VPAConfig {\n  vpa: string; // Format: user@upi\n  beneficiaryName?: string;\n}\n\n// VPA validation\nfunction validateVPA(vpa: string): boolean {\n  const vpaRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+$/;\n  return vpaRegex.test(vpa);\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-mobile-money-integration",children:"3. Mobile Money Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Mobile money configuration\ninterface MobileMoneyConfig {\n  phoneNumber: string;\n  provider: 'MPESA' | 'AIRTEL_MONEY' | 'MTN_MOBILE_MONEY';\n  country: string;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"error-handling-and-retry-logic",children:"Error Handling and Retry Logic"}),"\n",(0,a.jsx)(e.h3,{id:"1-error-types",children:"1. Error Types"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"enum OfframpErrorType {\n  INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS',\n  INVALID_ACCOUNT = 'INVALID_ACCOUNT',\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  TIMEOUT = 'TIMEOUT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  INVALID_VPA = 'INVALID_VPA',\n  BANK_NOT_SUPPORTED = 'BANK_NOT_SUPPORTED'\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-retry-configuration",children:"2. Retry Configuration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface RetryConfig {\n  maxAttempts: number;\n  backoffDelay: number;\n  exponentialBackoff: boolean;\n}\n\nconst defaultRetryConfig: RetryConfig = {\n  maxAttempts: 3,\n  backoffDelay: 1000, // 1 second\n  exponentialBackoff: true\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-error-handling-implementation",children:"3. Error Handling Implementation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"async processOfframpWithRetry(\n  payload: FSPOfframpDetails,\n  retryConfig: RetryConfig = defaultRetryConfig\n): Promise<OfframpResponse> {\n  let lastError: Error;\n  \n  for (let attempt = 1; attempt <= retryConfig.maxAttempts; attempt++) {\n    try {\n      const offrampRequest = await this.generateOfframpPayload(\n        payload.offrampType,\n        payload\n      );\n      \n      return await this.offrampService.instantOfframp(offrampRequest);\n    } catch (error) {\n      lastError = error;\n      \n      if (attempt === retryConfig.maxAttempts) {\n        throw error;\n      }\n      \n      // Calculate delay with exponential backoff\n      const delay = retryConfig.exponentialBackoff \n        ? retryConfig.backoffDelay * Math.pow(2, attempt - 1)\n        : retryConfig.backoffDelay;\n      \n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  \n  throw lastError;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"monitoring-and-analytics",children:"Monitoring and Analytics"}),"\n",(0,a.jsx)(e.h3,{id:"1-transaction-tracking",children:"1. Transaction Tracking"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"interface TransactionMetrics {\n  totalTransactions: number;\n  successfulTransactions: number;\n  failedTransactions: number;\n  averageProcessingTime: number;\n  totalAmount: number;\n  successRate: number;\n}\n\nasync getTransactionMetrics(timeRange: DateRange): Promise<TransactionMetrics> {\n  const transactions = await this.prisma.beneficiaryRedeem.findMany({\n    where: {\n      createdAt: {\n        gte: timeRange.start,\n        lte: timeRange.end\n      }\n    }\n  });\n\n  const successful = transactions.filter(t => t.status === 'COMPLETED');\n  const failed = transactions.filter(t => t.status === 'FAILED');\n  \n  return {\n    totalTransactions: transactions.length,\n    successfulTransactions: successful.length,\n    failedTransactions: failed.length,\n    averageProcessingTime: this.calculateAverageProcessingTime(transactions),\n    totalAmount: transactions.reduce((sum, t) => sum + t.amount, 0),\n    successRate: (successful.length / transactions.length) * 100\n  };\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-status-tracking",children:"2. Status Tracking"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"enum PayoutStatus {\n  PENDING = 'PENDING',\n  PROCESSING = 'PROCESSING',\n  COMPLETED = 'COMPLETED',\n  FAILED = 'FAILED',\n  CANCELLED = 'CANCELLED'\n}\n\ninterface BeneficiaryRedeem {\n  uuid: string;\n  beneficiaryId: string;\n  payoutUUID: string;\n  amount: number;\n  status: PayoutStatus;\n  transactionHash?: string;\n  offrampResponse?: any;\n  errorMessage?: string;\n  numberOfAttempts: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"1-authentication",children:"1. Authentication"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Secure API authentication\nconst headers = {\n  'APP_ID': offrampSettings.appId,\n  'Authorization': `Bearer ${offrampSettings.accessToken}`,\n  'X-Request-ID': generateRequestId(),\n  'X-Timestamp': Date.now().toString()\n};\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-data-validation",children:"2. Data Validation"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Validate offramp request\nfunction validateOfframpRequest(request: OfframpRequest): boolean {\n  if (!request.tokenAmount || request.tokenAmount <= 0) {\n    throw new Error('Invalid token amount');\n  }\n  \n  if (!request.paymentProviderId) {\n    throw new Error('Payment provider ID is required');\n  }\n  \n  if (!request.transactionHash) {\n    throw new Error('Transaction hash is required');\n  }\n  \n  return true;\n}\n"})}),"\n",(0,a.jsx)(e.h3,{id:"3-rate-limiting",children:"3. Rate Limiting"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Implement rate limiting\n@Injectable()\nexport class RateLimitService {\n  private requestCounts = new Map<string, number>();\n  \n  async checkRateLimit(identifier: string, limit: number): Promise<boolean> {\n    const currentCount = this.requestCounts.get(identifier) || 0;\n    \n    if (currentCount >= limit) {\n      return false;\n    }\n    \n    this.requestCounts.set(identifier, currentCount + 1);\n    return true;\n  }\n}\n"})}),"\n",(0,a.jsx)(e.h2,{id:"testing",children:"Testing"}),"\n",(0,a.jsx)(e.h3,{id:"1-unit-tests",children:"1. Unit Tests"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"describe('OfframpService', () => {\n  let service: OfframpService;\n  let httpService: HttpService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        OfframpService,\n        {\n          provide: HttpService,\n          useValue: {\n            axiosRef: {\n              get: jest.fn(),\n              post: jest.fn()\n            }\n          }\n        }\n      ],\n    }).compile();\n\n    service = module.get<OfframpService>(OfframpService);\n    httpService = module.get<HttpService>(HttpService);\n  });\n\n  it('should fetch offramp settings', async () => {\n    const mockSettings = {\n      URL: 'https://api.test.com',\n      APP_ID: 'test_app_id',\n      ACCESS_TOKEN: 'test_token'\n    };\n\n    jest.spyOn(service, 'fetchOfframpSettings').mockResolvedValue(mockSettings);\n    \n    const result = await service.fetchOfframpSettings();\n    expect(result.url).toBe(mockSettings.URL);\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h3,{id:"2-integration-tests",children:"2. Integration Tests"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"describe('Offramp Integration', () => {\n  it('should process complete offramp workflow', async () => {\n    // Test complete workflow from token transfer to cash distribution\n    const payoutUUID = 'test-payout-uuid';\n    \n    // Trigger payout\n    const result = await payoutsService.triggerPayout(payoutUUID);\n    expect(result).toBe('Payout Initiated Successfully');\n    \n    // Verify offramp processing\n    const redeemStatus = await prisma.beneficiaryRedeem.findMany({\n      where: { payoutUUID }\n    });\n    \n    expect(redeemStatus.length).toBeGreaterThan(0);\n    expect(redeemStatus[0].status).toBe('COMPLETED');\n  });\n});\n"})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(e.h3,{id:"1-configuration-management",children:"1. Configuration Management"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Store sensitive configuration in environment variables"}),"\n",(0,a.jsx)(e.li,{children:"Use database settings for dynamic configuration"}),"\n",(0,a.jsx)(e.li,{children:"Implement configuration validation"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement comprehensive error handling"}),"\n",(0,a.jsx)(e.li,{children:"Use retry logic with exponential backoff"}),"\n",(0,a.jsx)(e.li,{children:"Log detailed error information for debugging"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"3-monitoring",children:"3. Monitoring"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Track transaction success rates"}),"\n",(0,a.jsx)(e.li,{children:"Monitor processing times"}),"\n",(0,a.jsx)(e.li,{children:"Set up alerts for failed transactions"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"4-security",children:"4. Security"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Use secure authentication"}),"\n",(0,a.jsx)(e.li,{children:"Validate all input data"}),"\n",(0,a.jsx)(e.li,{children:"Implement rate limiting"}),"\n",(0,a.jsx)(e.li,{children:"Encrypt sensitive data"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"5-performance",children:"5. Performance"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Use batch processing for large volumes"}),"\n",(0,a.jsx)(e.li,{children:"Implement caching for frequently accessed data"}),"\n",(0,a.jsx)(e.li,{children:"Optimize database queries"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(e.h3,{id:"common-issues",children:"Common Issues"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Authentication Errors"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Verify APP_ID and ACCESS_TOKEN"}),"\n",(0,a.jsx)(e.li,{children:"Check token expiration"}),"\n",(0,a.jsx)(e.li,{children:"Ensure proper headers"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Network Timeouts"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Increase timeout values"}),"\n",(0,a.jsx)(e.li,{children:"Implement retry logic"}),"\n",(0,a.jsx)(e.li,{children:"Check network connectivity"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Invalid Payment Details"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Validate bank account numbers"}),"\n",(0,a.jsx)(e.li,{children:"Check VPA format"}),"\n",(0,a.jsx)(e.li,{children:"Verify beneficiary information"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"Rate Limiting"})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement request throttling"}),"\n",(0,a.jsx)(e.li,{children:"Use bulk endpoints for multiple transactions"}),"\n",(0,a.jsx)(e.li,{children:"Monitor API usage limits"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"debug-tools",children:"Debug Tools"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-typescript",children:"// Enable debug logging\nconst debugConfig = {\n  enableDebugLogs: true,\n  logLevel: 'DEBUG',\n  includeRequestData: true\n};\n\n// Debug logging implementation\nif (debugConfig.enableDebugLogs) {\n  console.log('Offramp Request:', JSON.stringify(request, null, 2));\n  console.log('Offramp Response:', JSON.stringify(response, null, 2));\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"This comprehensive documentation provides all the necessary information for implementing and maintaining offramp service integration with the Rahat platform."})]})}function f(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},28453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>o});var r=t(96540);const a={},i=r.createContext(a);function s(n){const e=r.useContext(i);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);